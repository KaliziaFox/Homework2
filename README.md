# Homework2
Вариант 8


В начале программа ожидает на вход 3 аргумента (адрес файла, режим работы (encryption/decryption) и имя файла). Их вводим с помощью функционала CLine.

![image](https://user-images.githubusercontent.com/112780370/206865825-5c8ef3a4-a688-48b8-a62a-cbee97d28cd3.png)

Преимущество этого подхода перед вводом с клавиатуры ( cin ), в том, что программа не ожидает действий от пользователя. Пользователь в дальнейшем будет вводить только ключ и само зашифровываемое сообщение.
 
Выделяем память под переменную, означающую режим программы mode, и закладываем в неё значение второго аргумента arg[1]. 
Аналогично для имени файла file_name и третьего аргумента arg[2].
Просим пользователя ввести ключ key.
Затем, в зависимости от выбранного режима (зашифровка/расшифровка), переходим к следующему блоку:

РЕЖИМ ШИФРОВАНИЕ

Просим пользователя ввести сообщение password, которое необходимо зашифровать.

Выделяем память под переменные, которые потребуются нам в дальнейшем. Выделяем память под переменную put_in_file для записи в файл. Теперь программа знает, что в дальнейшем планируется запись в файл.

Связываем переменную put_in_file с именем файла file_name и режимом binary, в котором мы его считываем. Т.е получили открытый файл в двоичном режиме для записи.

При помощи цикла for проходим по всем символам строки password c шагом 2 (тк размер обрабатываемого блока данных 2 байта).

Записываем в переменную gamma псевдослучайное число, созданное при помощи функции srand от ключа, заданного пользователем.

Каждый символ блока записываем в переменные b1 и b2. При этом не забываем проверять при помощи цикла if, кончилась строка или ещё нет. Если строка всё же преждевременно (до выхода из блока) кончилась, то записываем в b2 ноль типа unsigned int.

Теперь формируем блок block из двух переменных b1 и b2.

static_cast - оператор приведенияя типов. 

static_cast((unsigned int))(b1) - перевод символа, хранящегося в переменной b1 / b2, из типа char в тип unsigned int. Все буквы будут заменяться на числа - номера кодировки по UTF-8.
 
Теперь мы побитово сложим (поразрядное "или") переменные b1 и b2 и получим искомый блок. Для склеивания блока таким образом, чтобы b1 стояла перед b2, b1 сдвигаем влево на 8 позиций, оставшееся место автоматически заполнится нулями.

Применим поразрядный ксор для block и gamma, тем самым изменив блок. 
 
shift - сдвинутый влево блок.
 
<< 3u - сдвинули на 3 влево и потеряли начало. Значит, начало нужно вернуть (>> 13u), т.е. сдвинуть на 13 вправо (16 - 3 = 13) и применить поразрядное "или".
 
Переменные r1 и r2 изначально заданы не типом int, а типом char (8 бит = 1 байт). Следовательно в них влезет только 8 таких ячеек, а у нас их 16. Тогда мы разбили shift на 2 переменные по 8.
 
Записиываем друг за другом наши преобразованные символы в файл. Всё преобразовалось однозначно. Т.е. если изначальноу нас было 5 символов, то они  превратились в 5 новых символов.
 
Рассмотрим пример для сообщения qwerty

![image](https://user-images.githubusercontent.com/112780370/206865121-7ab992d6-1951-460e-9537-8d858a105a0d.png)

 
Режим расшифрования аналогичен режиму шифрования, только все операции проводятся в обратном порядке. На этот раз открываем файл на считывание. Сдвиг будет не влево, а вправо (снова на 3 бита, это не изменилось). Расшифрованные символы записываем в массив. Этот массив (строку) выводим на экран.
